package handlers

import (
	"net/http"
	"net/http/httptest"
	"rauth/internal/core"
	"testing"

	"github.com/alicebob/miniredis/v2"
	"github.com/labstack/echo/v4"
	"github.com/redis/go-redis/v9"
	"github.com/stretchr/testify/assert"
)

func TestPentest_OpenRedirect_Fixed(t *testing.T) {
	cfg := &core.Config{
		CookieDomains: []string{"example.com"},
		AllowedHosts:  []string{"localhost"},
	}

	t.Run("Safe redirect to subdomain", func(t *testing.T) {
		assert.True(t, cfg.IsAllowedHost("app.example.com"))
	})

	t.Run("Safe redirect to exact domain", func(t *testing.T) {
		assert.True(t, cfg.IsAllowedHost("example.com"))
	})

	t.Run("FIXED: Suffix abuse is now rejected", func(t *testing.T) {
		assert.False(t, cfg.IsAllowedHost("evil-example.com"), "Suffix match should be rejected if no dot prefix")
	})

	t.Run("URL with protocol should not be allowed directly", func(t *testing.T) {
		assert.False(t, cfg.IsAllowedHost("http://example.com"))
	})
}

func TestPentest_TokenEncryption(t *testing.T) {
	secret := "32-byte-long-secret-for-aes-gcm!!"
	token := "sensitive-token-123"
	
	encrypted, err := core.EncryptToken(token, secret)
	assert.NoError(t, err)
	assert.NotEqual(t, token, encrypted)
	
	decrypted, err := core.DecryptToken(encrypted, secret)
	assert.NoError(t, err)
	assert.Equal(t, token, decrypted)
}

func TestPentest_SSRF_GeoIP(t *testing.T) {
	t.Run("IP validation prevents SSRF", func(t *testing.T) {
		// Test behavior with invalid/malicious IP strings
		// Current logic returns "Internal" for non-IP strings because they fail parsing and IsPrivateIP returns true
		assert.Equal(t, "Internal", core.GetCountryCode("127.0.0.1; rm -rf /"))
		assert.Equal(t, "Internal", core.GetCountryCode("http://internal-service/"))
	})
}

func TestPentest_WebAuthn_Replay_Prevention(t *testing.T) {
	s := miniredis.RunT(t)
	defer s.Close()

	core.TokenDB = redis.NewClient(&redis.Options{Addr: s.Addr()})
	core.UserDB = core.TokenDB

	cfg := &core.Config{
		CookieDomains: []string{"localhost"},
		ServerSecret:  "testsecret1234567890123456789012",
	}
	_ = core.InitWebAuthn(cfg)

	h := &WebAuthnHandler{Cfg: cfg}
	e := echo.New()

	t.Run("Challenge is deleted after first retrieval", func(t *testing.T) {
		core.CreateUser("testuser", "password123", "test@example.com", false, "")
		// 1. Begin Registration to generate challenge
		req := httptest.NewRequest(http.MethodGet, "/webauthn/register/begin", nil)
		rec := httptest.NewRecorder()
		c := e.NewContext(req, rec)
		c.Set("username", "testuser")

		err := h.BeginRegistration(c)
		assert.NoError(t, err)
		assert.Equal(t, http.StatusOK, rec.Code)

		// Verify challenge exists in Redis
		redisKey := "webauthn_reg:testuser"
		val, err := core.TokenDB.Get(core.Ctx, redisKey).Result()
		assert.NoError(t, err)
		assert.NotEmpty(t, val)

		// 2. Simulate FinishRegistration (which should delete the challenge)
		// We don't need a valid signature for this test, just to hit the retrieval part
		reqFinish := httptest.NewRequest(http.MethodPost, "/webauthn/register/finish", nil)
		recFinish := httptest.NewRecorder()
		cFinish := e.NewContext(reqFinish, recFinish)
		cFinish.Set("username", "testuser")

		// This will fail verification but should have deleted the challenge
		_ = h.FinishRegistration(cFinish)

		// 3. Verify challenge is GONE
		_, err = core.TokenDB.Get(core.Ctx, redisKey).Result()
		assert.Error(t, err)
		assert.Equal(t, redis.Nil, err)
	})
}

func TestPentest_CSRF_Protection(t *testing.T) {
	// Echo's CSRF middleware is tested in handlers/csrf_test.go
	// This serves as a placeholder for manual verification of critical routes.
}